use crate::prelude::*;

use btc_heritage_wallet::heritage_service_api_client::Heir as ServiceHeir;

use crate::{
    components::{
        badge::UIHeirBadges,
        svg::{Alert, DrawSvg},
    },
    utils::{heir_config_type_to_string, CCStr, CheapClone},
    views::CreateLinkButton,
    Route,
};

#[component]
pub fn HeirListView() -> Element {
    log::debug!("HeirListView Rendered");

    use_drop(|| log::debug!("HeirListView Dropped"));
    rsx! {
        super::super::TitledView {
            title: CCStr::from("Heirs"),
            subtitle: CCStr::from(
                "Heirs that you can reference in the Heritage configuration of your wallets.",
            ),
            HeirList {}

            OnboardingInfoModal { step: OnboardingStep::ModalExplainHeirs,
                div { class: "flex flex-col gap-4 max-w-xl text-base",
                    p {
                        "Here you can declare and manage your heirs: the people who will inherit your Bitcoin in case something happens to you."
                    }

                    div { class: "bg-base-200 p-4 rounded-lg",
                        div { class: "font-semibold mb-3", "What really are Heirs?" }
                        p { class: "text-sm mb-2",
                            "Heirs are a way to connect Bitcoin public keys to real people with names and email addresses.
                            Each heir has their own private keys (mnemonic seed) that they control."
                        }
                        p { class: "text-sm mb-2",
                            "Bitcoin public and private keys can be generated by you and then distributed to your heirs,
                            or they can generate keys on their own and give you only the public keys for you to import."
                        }
                        p { class: "text-sm",
                            "Either way, once you've declared your heirs, you'll use them to create the Heritage Configuration
                            for your wallet, which defines inheritance order and timing conditions."
                        }
                    }

                    p {
                        "Your first heir will be a \"Backup\" heir for yourself. This serves as a recovery method
                            if you lose access to your wallet (for example, if your Ledger device is lost or damaged)."
                    }
                    p {
                        "This backup heir will have its own mnemonic seed that you control, providing an independent
                            way to access your funds when needed."
                    }
                
                }
            }

            OnboardingInfoModal { step: OnboardingStep::ModalMoreHeirOrWallet,
                div { class: "flex flex-col gap-4 max-w-2xl text-base",
                    p { "Your \"backup\" heir is ready for use. Now you can either:" }

                    div { class: "bg-base-200 p-4 rounded-lg",
                        div { class: "font-semibold text-xl mb-3", "Option 1: Add More Heirs" }
                        p { class: "mb-2",
                            "Create additional heirs for family members like your spouse or parents.
                            Each will have their own mnemonic seed and you will choose the order in which
                            they inherit."
                        }
                        p { class: "mb-2",
                            "The creation process is the same for each heir. Simply adapt the name, email, etc..."
                        }
                        div { class: "alert alert-info",
                            DrawSvg::<Alert> {}
                            p {
                                "Do not forget to write down and distribute their mnemonic and fingerprint to each heir
                                and advise them on how to store those informations. Once safely stored offline,
                                strip the seed from the app so no online copy remains."
                            }
                        }
                    }
                    div { class: "bg-base-200 p-4 rounded-lg",
                        div { class: "font-semibold text-xl mb-3",
                            "Option 2: Finish the Heritage Wallet Setup"
                        }
                        p { class: "mb-2",
                            "Proceed to create your Heritage Configuration, which defines the heir
                            inheritance order and timelock conditions for your wallet."
                        }
                    }
                }
            }
        }
    }
}

#[component]
fn HeirList() -> Element {
    log::debug!("HeirList Rendered");

    let service_heirs = use_context::<FResource<Vec<CheapClone<ServiceHeir>>>>();
    let composite_heirs = use_context::<Memo<Vec<CompositeHeir>>>();
    let service_loading = service_heirs.read().is_none();

    use_drop(|| log::debug!("HeirList Dropped"));

    rsx! {
        div { class: "container mx-auto grid grid-cols-[repeat(auto-fill,var(--container-2xs))] gap-6 justify-center",
            for (heir_index , composite_heir) in composite_heirs.read().iter().enumerate() {
                MaybeHighlight {
                    step: OnboardingStep::ClickHeirCard,
                    context_filter: OnboardingContextItemId::HeirName.item(composite_heir.name.to_string()),
                    div {
                        class: "cursor-pointer transition-transform hover:scale-105",
                        onclick: move |_| {
                            navigator().push(Route::HeirView { heir_index });
                        },
                        LoadedComponent::<UIHeirItem> { input: composite_heir.ref_into() }
                    }
                }
            }
            if service_loading {
                LoadedComponent::<UIHeirItem> { input: None::<UIHeirItem>.into() }
            }
            MaybeHighlight {
                step: OnboardingStep::ClickCreateHeirCard,
                context_callback: || Some((
                    OnboardingContextItemId::KeyProviderCreationRoute
                        .item((Route::HeirCreateView {}).to_string()),
                    true,
                )),
                CreateLinkButton {
                    route: Route::HeirCreateView {},
                    label: CCStr::from("Create Heir"),
                    size_classes: Some(CCStr::from("w-2xs aspect-square")),
                }
            }
        

        }
    }
}

#[derive(Debug, Clone, PartialEq)]
struct UIHeirItem {
    name: CCStr,
    heir_config_type: &'static str,
    heir_config_fingerprint: CCStr,
    badges: UIHeirBadges,
    service_loading: bool,
}
impl LoadedSuccessConversionMarker for TypeCouple<CompositeHeir, UIHeirItem> {}
impl FromRef<CompositeHeir> for UIHeirItem {
    fn from_ref(composite_heir: &CompositeHeir) -> Self {
        let badges = UIHeirBadges::from_ref(composite_heir);

        let CompositeHeir {
            name, heir_config, ..
        } = composite_heir;
        let name = name.clone();
        let heir_config_type = heir_config_type_to_string(heir_config);
        let heir_config_fingerprint = CCStr::from(heir_config.fingerprint().to_string());

        Self {
            name,
            heir_config_type,
            heir_config_fingerprint,
            badges: badges.into(),
            service_loading: composite_heir.service_heir.is_none(),
        }
    }
}
impl LoadedElement for UIHeirItem {
    type Loader = TransparentLoader;
    #[inline(always)]
    fn element<M: LoadedComponentInputMapper>(self, m: M) -> Element {
        rsx! {
            div { class: "card card-lg border shadow-xl w-2xs aspect-square",
                div { class: "card-body",
                    div { class: "card-title text-3xl font-black",
                        LoadedComponent { input: m.map(self.name) }
                    }
                    div { class: "flex flex-col",
                        div { class: "font-light", "Type" }
                        div { class: "text-lg font-bold text-nowrap",
                            LoadedComponent { input: m.map(self.heir_config_type) }
                        }
                    }
                    div { class: "flex flex-col",
                        div { class: "font-light text-nowrap", "Key Fingerprint" }
                        div { class: "text-lg font-bold",
                            LoadedComponent { input: m.map(self.heir_config_fingerprint) }
                        }
                    }

                    div { class: "grow" }

                    div { class: "flex flex-row flex-wrap justify-center gap-2",
                        LoadedComponent { input: m.map(self.badges) }
                    }
                }
            }
        }
    }
    fn place_holder() -> Self {
        Self {
            name: CCStr::place_holder(),
            heir_config_type: <&str>::place_holder(),
            heir_config_fingerprint: CCStr::place_holder(),
            badges: UIHeirBadges::place_holder(),
            service_loading: false,
        }
    }
}
